from typing import *
from dataclasses import dataclass, field
from pathlib import Path
from abc import ABC, abstractmethod

FilePath = Path
DirPath = Path


@dataclass
class ConversionOutcome():
    """
    Represents the result of a single file conversion operation with comprehensive status tracking.

    This class encapsulates all information about a conversion attempt, including success/failure status,
    generated files, warnings, and error details. It supports various outcome scenarios from successful
    conversions to skipped files and critical errors that halt processing.

    Attributes:
        input_file (FilePath): The source file that was processed during conversion.
        output_files (List[FilePath]): List of files generated by the conversion. Empty if conversion failed.
        warning_messages (List[str]): Non-critical issues encountered during conversion.
        
        skipped (bool): True if conversion was skipped (e.g., output already exists). Default: False.
        successful (bool): True if conversion completed successfully. Default: True.
        error_message (str): Detailed error description if conversion failed. Default: empty string.
        halt (bool): True if this error should stop the entire conversion process. Default: False.

    Examples:
        >>> # Successful conversion
        >>> outcome = ConversionOutcome(
        ...     input_file=Path("song.pdf"),
        ...     output_files=[Path("song.mxl")],
        ...     successful=True
        ... )
        
        >>> # Failed conversion
        >>> outcome = ConversionOutcome(
        ...     input_file=Path("corrupt.pdf"),
        ...     successful=False,
        ...     error_message="File corrupted, cannot parse PDF"
        ... )
        
        >>> # Skipped conversion
        >>> outcome = ConversionOutcome(
        ...     input_file=Path("song.pdf"),
        ...     skipped=True,
        ...     error_message="Output file already exists"
        ... )
    """
    input_file: FilePath
    output_files: List[FilePath] = field(default_factory=list)
    warning_messages: List[str] = field(default_factory=list)
    
    skipped: bool = False
    successful: bool = True
    error_message: str = ""
    halt: bool = False


class SingleFileConversionFunction(ABC):
    """
    Abstract base class for conversion functions that process files individually.

    This class defines the interface for single-file conversion operations. Each conversion
    processes one input file at a time, providing granular control and detailed error tracking
    for individual files. Suitable for conversions that don't benefit from batch processing
    or require per-file customization.

    Class Attributes:
        is_batchable (ClassVar[bool]): Always False, indicating this class handles single files only.

    Abstract Methods:
        skip_single_file(): Determines if a file should be skipped (e.g., output exists,...)
        conversion(): Performs the actual file conversion
        clean_up(): Handles resource cleanup after conversion

    Usage Pattern:
        1. Check if file should be skipped (if overwrite=False)
        2. Perform conversion
        3. Clean up resources (always executed)

    Example Implementation:
        >>> class PDFToMXLConverter(SingleFileConversionFunction):
        ...     def skip_single_file(self, input_file, output_dir):
        ...         output_file = output_dir / f"{input_file.stem}.mxl"
        ...         if output_file.exists():
        ...             return ConversionOutcome(input_file, skipped=True)
        ...         return None
        ...     
        ...     def conversion(self, input_file, output_dir):
        ...         # Perform PDF to MXL conversion
        ...         result_file = convert_pdf_to_mxl(input_file, output_dir)
        ...         return ConversionOutcome(input_file, [result_file])
        ...     
        ...     def clean_up(self, input_file, output_dir):
        ...         # Clean temporary files
        ...         pass
    """
    is_batchable: ClassVar[bool] = False

    @abstractmethod
    def skip_single_file(self, input_file: FilePath, output_dir: DirPath) -> ConversionOutcome | None: 
        """
        Determines whether a single file should be skipped during conversion.

        This method checks if conversion should be bypassed, typically because the output
        file already exists. Should return a ConversionOutcome with skipped=True if the
        file should be skipped, or None if conversion should proceed.

        Args:
            input_file (FilePath): The source file to check for skipping.
            output_dir (DirPath): Directory where the converted file would be saved.

        Returns:
            ConversionOutcome | None: ConversionOutcome with skipped=True if file should be skipped,
                None if conversion should proceed.

        Example:
            >>> def skip_single_file(self, input_file, output_dir):
            ...     output_file = output_dir / f"{input_file.stem}.mxl"
            ...     if output_file.exists():
            ...         return ConversionOutcome(
            ...             input_file=input_file,
            ...             skipped=True,
            ...             error_message="Output file already exists"
            ...         )
            ...     return None
        """
        ... 

    @abstractmethod
    def conversion(self, input_file: FilePath, output_dir: DirPath) -> ConversionOutcome: 
        """
        Performs the actual single-file conversion operation.

        This method contains the core conversion logic. It should read the input file,
        perform the format transformation, write output files, and return a ConversionOutcome
        with details about the operation result.

        Error Handling:
            - All exceptions should be caught and recorded in ConversionOutcome.error_message
            - Set successful=False for any conversion failures
            - Set halt=True only for critical errors that should stop the entire batch

        Args:
            input_file (FilePath): The source file to convert.
            output_dir (DirPath): Directory where converted files should be saved.

        Returns:
            ConversionOutcome: Result of the conversion with success status, output files,
                warnings, and any error messages.

        Example:
            >>> def conversion(self, input_file, output_dir):
            ...     try:
            ...         output_file = output_dir / f"{input_file.stem}.mxl"
            ...         # Perform conversion logic here
            ...         convert_pdf_to_musicxml(input_file, output_file)
            ...         return ConversionOutcome(
            ...             input_file=input_file,
            ...             output_files=[output_file],
            ...             successful=True
            ...         )
            ...     except Exception as e:
            ...         return ConversionOutcome(
            ...             input_file=input_file,
            ...             successful=False,
            ...             error_message=str(e)
            ...         )
        """
        ...   
    
    @abstractmethod
    def clean_up(self, input_file: FilePath, output_dir: DirPath) -> None: 
        """
        Performs cleanup after single-file conversion.

        This method handles resource cleanup that should occur after every conversion attempt,
        regardless of success or failure. Use this to close files, delete temporary files,
        release memory, or finalize any resources used during conversion.

        Note:
            This method is called in a finally block, so it will execute even if
            conversion() raises an exception.

        Args:
            input_file (FilePath): The input file that was processed.
            output_dir (DirPath): The output directory used for conversion.

        Example:
            >>> def clean_up(self, input_file, output_dir):
            ...     # Remove temporary files
            ...     temp_dir = output_dir / "temp"
            ...     if temp_dir.exists():
            ...         shutil.rmtree(temp_dir)
            ...     
            ...     # Close any open file handles
            ...     if hasattr(self, '_open_handles'):
            ...         for handle in self._open_handles:
            ...             handle.close()
        """
        ... 

    def __call__(self, input_file: FilePath, output_dir: DirPath, overwrite: bool = True) -> ConversionOutcome: 
        """
        Executes the complete single-file conversion workflow.

        This method orchestrates the conversion process by checking for skip conditions,
        performing the conversion, and ensuring cleanup occurs. It implements the standard
        conversion workflow that subclasses rely on.

        Workflow:
            1. If overwrite=False, check if file should be skipped
            2. If not skipped, perform conversion via conversion()
            3. Always perform cleanup via clean_up() (even if conversion fails)

        Args:
            input_file (FilePath): Source file to convert.
            output_dir (DirPath): Directory where converted file will be saved.
            overwrite (bool, optional): Whether to overwrite existing output files. Defaults to True.

        Returns:
            ConversionOutcome: Result of the conversion operation.

        Example:
            >>> converter = MyPDFConverter()
            >>> outcome = converter(Path("song.pdf"), Path("output/"), overwrite=False)
            >>> if outcome.successful:
            ...     print(f"Converted to: {outcome.output_files}")
            >>> elif outcome.skipped:
            ...     print("Conversion skipped - file already exists")
        """
        
        if not overwrite:
            if skip := self.skip_single_file(input_file, output_dir):
                return skip
        
        try:
            return self.conversion(input_file, output_dir)
        
        finally:
            self.clean_up(input_file, output_dir)


class BatchConversionFunction(ABC):
    """
    Abstract base class for conversion functions that can process files individually or in batches.

    This class supports both single-file and batch processing modes, allowing for efficient
    bulk operations while maintaining the flexibility to process individual files when needed.
    Batch processing is typically faster and more resource-efficient for large-scale conversions.

    Class Attributes:
        is_batchable (ClassVar[bool]): Always True, indicating this class supports batch operations.

    Operating Modes:
        - Single-file mode: Processes one file at a time (do_batch=False)
        - Batch mode: Processes all files in a directory simultaneously (do_batch=True)

    Abstract Methods:
        skip_single_file(): Determines if a single file should be skipped
        single_file_conversion(): Performs single-file conversion
        batch_conversion(): Performs batch conversion of all files in a directory
        single_file_clean_up(): Cleanup after single-file conversion
        batch_clean_up(): Cleanup after batch conversion

    Example Implementation:
        >>> class MIDITokenizer(BatchConversionFunction):
        ...     def batch_conversion(self, input_dir, output_dir, overwrite=True):
        ...         outcomes = []
        ...         midi_files = list(input_dir.glob("*.midi"))
        ...         tokenized_data = self.tokenizer.encode_batch(midi_files)
        ...         
        ...         for midi_file, tokens in zip(midi_files, tokenized_data):
        ...             output_file = output_dir / f"{midi_file.stem}.json"
        ...             output_file.write_text(json.dumps(tokens))
        ...             outcomes.append(ConversionOutcome(midi_file, [output_file]))
        ...         
        ...         return outcomes
    """
    is_batchable: ClassVar[bool] = True

    @abstractmethod
    def skip_single_file(self, input_file: FilePath, output_dir: DirPath) -> ConversionOutcome | None:
        """
        Determines whether a single file should be skipped during conversion.

        Used only in single-file mode (do_batch=False). Checks if conversion should be
        bypassed, typically because the output file already exists.

        Args:
            input_file (FilePath): The source file to check for skipping.
            output_dir (DirPath): Directory where the converted file would be saved.

        Returns:
            ConversionOutcome | None: ConversionOutcome with skipped=True if file should be skipped,
                None if conversion should proceed.

        Example:
            >>> def skip_single_file(self, input_file, output_dir):
            ...     output_file = output_dir / f"{input_file.stem}.json"
            ...     if output_file.exists():
            ...         return ConversionOutcome(input_file, skipped=True)
            ...     return None
        """
        ... 

    @abstractmethod
    def single_file_conversion(self, input_file: FilePath, output_dir: DirPath) -> ConversionOutcome:
        """
        Performs single-file conversion when operating in non-batch mode.

        This method handles conversion of a single file when batch processing is not
        desired or available. It should implement the same conversion logic as batch_conversion
        but optimized for single-file processing.

        Args:
            input_file (FilePath): The source file to convert.
            output_dir (DirPath): Directory where the converted file should be saved.

        Returns:
            ConversionOutcome: Result of the conversion with success status and output files.

        Example:
            >>> def single_file_conversion(self, input_file, output_dir):
            ...     try:
            ...         tokens = self.tokenizer.encode(input_file)
            ...         output_file = output_dir / f"{input_file.stem}.json"
            ...         output_file.write_text(json.dumps(tokens))
            ...         return ConversionOutcome(input_file, [output_file])
            ...     except Exception as e:
            ...         return ConversionOutcome(input_file, successful=False, error_message=str(e))
        """
        ...   

    @abstractmethod
    def batch_conversion(self, input_dir: DirPath, output_dir: DirPath, overwrite: bool = True) -> List[ConversionOutcome]:
        """
        Performs batch conversion of all eligible files in the input directory.

        This method processes multiple files simultaneously, which can be significantly
        more efficient than individual file processing. It should handle file filtering,
        batch processing logic, and generate individual ConversionOutcome objects for each file.

        Args:
            input_dir (DirPath): Directory containing input files to convert.
            output_dir (DirPath): Directory where converted files will be saved.
            overwrite (bool, optional): Whether to overwrite existing output files. Defaults to True.

        Returns:
            List[ConversionOutcome]: List of conversion results, one for each processed file.

        Example:
            >>> def batch_conversion(self, input_dir, output_dir, overwrite=True):
            ...     outcomes = []
            ...     midi_files = list(input_dir.glob("*.midi"))
            ...     
            ...     if not overwrite:
            ...         # Filter out files that would be skipped
            ...         midi_files = [f for f in midi_files 
            ...                      if not (output_dir / f"{f.stem}.json").exists()]
            ...     
            ...     # Batch process all files at once
            ...     try:
            ...         tokenized_batch = self.tokenizer.encode_batch(midi_files)
            ...         for midi_file, tokens in zip(midi_files, tokenized_batch):
            ...             output_file = output_dir / f"{midi_file.stem}.json"
            ...             output_file.write_text(json.dumps(tokens))
            ...             outcomes.append(ConversionOutcome(midi_file, [output_file]))
            ...     except Exception as e:
            ...         # Handle batch failure
            ...         for midi_file in midi_files:
            ...             outcomes.append(ConversionOutcome(
            ...                 midi_file, successful=False, error_message=str(e)
            ...             ))
            ...     
            ...     return outcomes
        """
        ...
    
    @abstractmethod
    def single_file_clean_up(self, input_file: FilePath, output_dir: DirPath) -> None:
        """
        Performs cleanup after single-file conversion.

        This method handles resource cleanup for single-file operations. Called after
        single_file_conversion() in a finally block to ensure cleanup occurs even if
        conversion fails.

        Args:
            input_file (FilePath): The input file that was processed.
            output_dir (DirPath): The output directory used for conversion.

        Example:
            >>> def single_file_clean_up(self, input_file, output_dir):
            ...     # Clean up temporary files for this specific conversion
            ...     temp_file = output_dir / f"{input_file.stem}.tmp"
            ...     if temp_file.exists():
            ...         temp_file.unlink()
        """
        ...
    
    @abstractmethod
    def batch_clean_up(self, input_dir: DirPath, output_dir: DirPath) -> None:
        """
        Performs cleanup after batch conversion.

        This method handles resource cleanup for batch operations. Called after
        batch_conversion() in a finally block to ensure cleanup occurs even if
        batch processing fails.

        Args:
            input_dir (DirPath): The input directory that was processed.
            output_dir (DirPath): The output directory used for conversion.

        Example:
            >>> def batch_clean_up(self, input_dir, output_dir):
            ...     # Clean up shared resources used during batch processing
            ...     if hasattr(self, 'temp_workspace'):
            ...         shutil.rmtree(self.temp_workspace)
            ...     
            ...     # Release batch processing resources
            ...     if hasattr(self.tokenizer, 'cleanup_batch'):
            ...         self.tokenizer.cleanup_batch()
        """
        ...
    
    @overload
    def __call__(self, input_path: FilePath, output_dir: DirPath, do_batch: Literal[False], overwrite: bool = True) -> ConversionOutcome:...
    
    @overload
    def __call__(self, input_path: DirPath, output_dir: DirPath, do_batch: Literal[True], overwrite: bool = True) -> List[ConversionOutcome]:...

    def __call__(self, input_path: Union[FilePath, DirPath], output_dir: DirPath, do_batch: bool = True, overwrite: bool = True) -> List[ConversionOutcome] | ConversionOutcome: 
        """
        Executes conversion in either batch or single-file mode based on parameters.

        This method provides a unified interface for both conversion modes. It automatically
        handles the appropriate workflow for each mode, including skip checking, conversion
        execution, and cleanup.

        Single-file Mode (do_batch=False):
            1. Check if file should be skipped (if overwrite=False)
            2. Perform single_file_conversion()
            3. Perform single_file_clean_up()

        Batch Mode (do_batch=True):
            1. Perform batch_conversion() (handles overwrite internally)
            2. Perform batch_clean_up()

        Args:
            input_path (Union[FilePath, DirPath]): Source file (single-file mode) or 
                directory (batch mode) to convert.
            output_dir (DirPath): Directory where converted files will be saved.
            do_batch (bool, optional): Whether to use batch processing. Defaults to True.
            overwrite (bool, optional): Whether to overwrite existing files. Defaults to True.

        Returns:
            List[ConversionOutcome] | ConversionOutcome: List of outcomes for batch mode,
                single outcome for single-file mode.

        Example:
            >>> converter = MyBatchConverter()
            >>> 
            >>> # Batch mode - process entire directory
            >>> outcomes = converter(Path("input/"), Path("output/"), do_batch=True)
            >>> print(f"Processed {len(outcomes)} files")
            >>> 
            >>> # Single-file mode - process one file
            >>> outcome = converter(Path("song.midi"), Path("output/"), do_batch=False)
            >>> if outcome.successful:
            ...     print(f"Converted to: {outcome.output_files}")
        """
        if do_batch:
            try:
                return self.batch_conversion(input_path, output_dir, overwrite)
            finally:
                self.batch_clean_up(input_path, output_dir)
        else:
            if not overwrite:
                if skip := self.skip_single_file(input_path, output_dir):
                    return skip
            try: 
                return self.single_file_conversion(input_path, output_dir)
            finally:
                self.single_file_clean_up(input_path, output_dir)
            
    
_ConversionFunction = Union[SingleFileConversionFunction, BatchConversionFunction]
